/*
 * AUTOGENERATED by mrustc
 */
#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#include <assert.h>
#include <stdatomic.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <setjmp.h>
typedef uint32_t RUST_CHAR;
typedef uint8_t RUST_BOOL;
typedef struct { void* PTR; size_t META; } SLICE_PTR;
typedef struct { void* PTR; void* META; } TRAITOBJ_PTR;
typedef struct { void (*drop)(void*); size_t size; size_t align; } VTABLE_HDR;
typedef struct { char _d; } tUNIT;
typedef char tBANG;
typedef struct { char _d; } tTYPEID;
static inline size_t ALIGN_TO(size_t s, size_t a) { return (s + a-1) / a * a; }

extern void _Unwind_Resume(void) __attribute__((noreturn));
#define ALIGNOF(t) __alignof__(t)
extern __thread jmp_buf*    mrustc_panic_target;
extern __thread void* mrustc_panic_value;
static inline uint64_t __builtin_clz64(uint64_t v) {
	return ( (v >> 32) != 0 ? __builtin_clz(v>>32) : 32 + __builtin_clz(v));
}
static inline uint64_t __builtin_ctz64(uint64_t v) {
	return ((v&0xFFFFFFFF) == 0 ? __builtin_ctz(v>>32) + 32 : __builtin_ctz(v));
}
static inline uint8_t __mrustc_atomicloop8(volatile uint8_t* slot, uint8_t param, int ordering, uint8_t (*cb)(uint8_t, uint8_t)) { int ordering_load = (ordering == memory_order_release || ordering == memory_order_acq_rel ? memory_order_relaxed : ordering); for(;;) { uint8_t v = atomic_load_explicit((_Atomic uint8_t*)slot, ordering_load); if( atomic_compare_exchange_strong_explicit((_Atomic uint8_t*)slot, &v, cb(v, param), ordering, ordering_load) ) return v; }}
static inline uint16_t __mrustc_atomicloop16(volatile uint16_t* slot, uint16_t param, int ordering, uint16_t (*cb)(uint16_t, uint16_t)) { int ordering_load = (ordering == memory_order_release || ordering == memory_order_acq_rel ? memory_order_relaxed : ordering); for(;;) { uint16_t v = atomic_load_explicit((_Atomic uint16_t*)slot, ordering_load); if( atomic_compare_exchange_strong_explicit((_Atomic uint16_t*)slot, &v, cb(v, param), ordering, ordering_load) ) return v; }}
static inline uint32_t __mrustc_atomicloop32(volatile uint32_t* slot, uint32_t param, int ordering, uint32_t (*cb)(uint32_t, uint32_t)) { int ordering_load = (ordering == memory_order_release || ordering == memory_order_acq_rel ? memory_order_relaxed : ordering); for(;;) { uint32_t v = atomic_load_explicit((_Atomic uint32_t*)slot, ordering_load); if( atomic_compare_exchange_strong_explicit((_Atomic uint32_t*)slot, &v, cb(v, param), ordering, ordering_load) ) return v; }}
static inline uint64_t __mrustc_atomicloop64(volatile uint64_t* slot, uint64_t param, int ordering, uint64_t (*cb)(uint64_t, uint64_t)) { int ordering_load = (ordering == memory_order_release || ordering == memory_order_acq_rel ? memory_order_relaxed : ordering); for(;;) { uint64_t v = atomic_load_explicit((_Atomic uint64_t*)slot, ordering_load); if( atomic_compare_exchange_strong_explicit((_Atomic uint64_t*)slot, &v, cb(v, param), ordering, ordering_load) ) return v; }}
typedef struct { uint64_t lo, hi; } uint128_t;
typedef struct { uint64_t lo, hi; } int128_t;
static inline uint128_t intrinsic_ctlz_u128(uint128_t v);
static inline uint128_t shl128(uint128_t a, uint32_t b);
static inline uint128_t shr128(uint128_t a, uint32_t b);
static inline float make_float(int is_neg, int exp, uint32_t mantissa_bits) { float rv; uint32_t vi=(mantissa_bits&((1<<23)-1))|((exp+127)<<23);if(is_neg)vi|=1<<31; memcpy(&rv, &vi, 4); return rv; }
static inline double make_double(int is_neg, int exp, uint32_t mantissa_bits) { double rv; uint64_t vi=(mantissa_bits&((1ull<<52)-1))|((uint64_t)(exp+1023)<<52);if(is_neg)vi|=1ull<<63; memcpy(&rv, &vi, 4); return rv; }
static inline uint128_t make128_raw(uint64_t hi, uint64_t lo) { uint128_t rv = { lo, hi }; return rv; }
static inline uint128_t make128(uint64_t v) { uint128_t rv = { v, 0 }; return rv; }
static inline float cast128_float(uint128_t v) { int n = intrinsic_ctlz_u128(v).lo; uint128_t y = shl128(v, n); uint64_t a = (y.hi >> ((128-(23+1))-64)); uint64_t b = shr128(y, (64-(23+1))).lo | (y.lo & 0xFFFFFFFFFF); uint64_t m = a + ((b - ((b >> 63) & ~a)) >> 63); uint64_t e = (v.lo == 0 && v.hi == 0) ? 0 : (127 - n)+127-1; uint32_t vi = (e << 23) + m; float rv; memcpy(&rv, &vi, sizeof(rv)); return rv; }
static inline double cast128_double(uint128_t v) { int n = intrinsic_ctlz_u128(v).lo; uint128_t y = shl128(v, n); uint64_t a = (y.hi >> ((128-(52+1))-64)); uint64_t b = shr128(y, (64-(52+1))).lo | (y.lo & 0x7FF); uint64_t m = a + ((b - (b >> 63 & ~a)) >> 63); uint64_t e = (v.lo == 0 && v.hi == 0) ? 0 : (127 - n)+1023-1; uint64_t vi = (e << 52) + m; double rv; memcpy(&rv, &vi, sizeof(rv)); return rv; }
static inline int cmp128(uint128_t a, uint128_t b) { if(a.hi != b.hi) return a.hi < b.hi ? -1 : 1; if(a.lo != b.lo) return a.lo < b.lo ? -1 : 1; return 0; }
static inline bool add128_o(uint128_t a, uint128_t b, uint128_t* o) { o->lo = a.lo + b.lo; o->hi = a.hi + b.hi + (o->lo < a.lo ? 1 : 0); return (o->hi < a.hi); }
static inline bool sub128_o(uint128_t a, uint128_t b, uint128_t* o) { o->lo = a.lo - b.lo; o->hi = a.hi - b.hi - (a.lo < b.lo ? 1 : 0); return (o->hi > a.hi); }
static inline bool mul128_o(uint128_t a, uint128_t b, uint128_t* o) { bool of = false; o->hi = 0; o->lo = 0; for(int i=0;i<128;i++){ uint64_t m = (1ull << (i % 64)); if(a.hi==0&&a.lo<m)   break; if(i>=64&&a.hi<m) break; if( m & (i >= 64 ? a.hi : a.lo) ) of |= add128_o(*o, b, o); b.hi = (b.hi << 1) | (b.lo >> 63); b.lo = (b.lo << 1); } return of;}
static inline bool div128_o(uint128_t a, uint128_t b, uint128_t* q, uint128_t* r) { if(a.hi == 0 && b.hi == 0) { if(q) { q->hi=0; q->lo = a.lo / b.lo; } if(r) { r->hi=0; r->lo = a.lo % b.lo; } return false; } if(cmp128(a, b) < 0) { if(q) { q->hi=0; q->lo=0; } if(r) *r = a; return false; } uint128_t a_div_2 = {(a.lo>>1)|(a.hi << 63), a.hi>>1}; int shift = 0; while( cmp128(a_div_2, b) >= 0 && shift < 128 ) { shift += 1; b.hi = (b.hi<<1)|(b.lo>>63); b.lo <<= 1; } if(shift == 128) return true; uint128_t mask = { /*lo=*/(shift >= 64 ? 0 : (1ull << shift)), /*hi=*/(shift < 64 ? 0 : 1ull << (shift-64)) }; shift ++; if(q) { q->hi = 0; q->lo = 0; } while(shift--) { if( cmp128(a, b) >= 0 ) { if(q) add128_o(*q, mask, q); sub128_o(a, b, &a); } mask.lo = (mask.lo >> 1) | (mask.hi << 63); mask.hi >>= 1; b.lo = (b.lo >> 1) | (b.hi << 63); b.hi >>= 1; } if(r) *r = a; return false;}
static inline uint128_t add128(uint128_t a, uint128_t b) { uint128_t v; add128_o(a, b, &v); return v; }
static inline uint128_t sub128(uint128_t a, uint128_t b) { uint128_t v; sub128_o(a, b, &v); return v; }
static inline uint128_t mul128(uint128_t a, uint128_t b) { uint128_t v; mul128_o(a, b, &v); return v; }
static inline uint128_t div128(uint128_t a, uint128_t b) { uint128_t v; div128_o(a, b, &v, NULL); return v; }
static inline uint128_t mod128(uint128_t a, uint128_t b) { uint128_t v; div128_o(a, b, NULL, &v); return v;}
static inline uint128_t and128(uint128_t a, uint128_t b) { uint128_t v = { a.lo & b.lo, a.hi & b.hi }; return v; }
static inline uint128_t or128 (uint128_t a, uint128_t b) { uint128_t v = { a.lo | b.lo, a.hi | b.hi }; return v; }
static inline uint128_t xor128(uint128_t a, uint128_t b) { uint128_t v = { a.lo ^ b.lo, a.hi ^ b.hi }; return v; }
static inline uint128_t shl128(uint128_t a, uint32_t b) { uint128_t v; if(b == 0) { return a; } else if(b < 64) { v.lo = a.lo << b; v.hi = (a.hi << b) | (a.lo >> (64 - b)); } else { v.hi = a.lo << (b - 64); v.lo = 0; } return v; }
static inline uint128_t shr128(uint128_t a, uint32_t b) { uint128_t v; if(b == 0) { return a; } else if(b < 64) { v.lo = (a.lo >> b)|(a.hi << (64 - b)); v.hi = a.hi >> b; } else { v.lo = a.hi >> (b - 64); v.hi = 0; } return v; }
static inline uint128_t popcount128(uint128_t a) { uint128_t v = { __builtin_popcountll(a.lo) + __builtin_popcountll(a.hi), 0 }; return v; }
static inline uint128_t __builtin_bswap128(uint128_t v) { uint128_t rv = { __builtin_bswap64(v.hi), __builtin_bswap64(v.lo) }; return rv; }
static inline uint128_t intrinsic_ctlz_u128(uint128_t v) {
	uint128_t rv = { (v.hi != 0 ? __builtin_clz64(v.hi) : (v.lo != 0 ? 64 + __builtin_clz64(v.lo) : 128)), 0 };
	return rv;
}
static inline uint128_t intrinsic_cttz_u128(uint128_t v) {
	uint128_t rv = { (v.lo == 0 ? (v.hi == 0 ? 128 : __builtin_ctz64(v.hi) + 64) : __builtin_ctz64(v.lo)), 0 };
	return rv;
}
static inline int128_t make128s_raw(uint64_t hi, uint64_t lo) { int128_t rv = { lo, hi }; return rv; }
static inline int128_t make128s(int64_t v) { int128_t rv = { v, (v < 0 ? -1 : 0) }; return rv; }
static inline int128_t neg128s(int128_t v) { int128_t rv = { ~v.lo+1, ~v.hi + (v.lo == 0) }; return rv; }
static inline float cast128s_float(int128_t v) { int sgn = (v.hi >> 63); int128_t abs = sgn ? neg128s(v) : v; return (sgn ? -1.0 : 1.0) * cast128_float(make128_raw(v.hi,v.lo)); }
static inline double cast128s_double(int128_t v) { int sgn = (v.hi >> 63); int128_t abs = sgn ? neg128s(v) : v; return (sgn ? -1.0 : 1.0) * cast128_double(make128_raw(v.hi,v.lo)); }
static inline int cmp128s(int128_t a, int128_t b) { if(a.hi != b.hi) return (int64_t)a.hi < (int64_t)b.hi ? -1 : 1; if(a.lo != b.lo) return a.lo < b.lo ? -1 : 1; return 0; }
static inline bool add128s_o(int128_t a, int128_t b, int128_t* o) { bool sgna=a.hi>>63; bool sgnb=b.hi>>63; add128_o(*(uint128_t*)&a, *(uint128_t*)&b, (uint128_t*)o); bool sgno = o->hi>>63; return (sgna==sgnb && sgno != sgna); }
static inline bool sub128s_o(int128_t a, int128_t b, int128_t* o) { bool sgna=a.hi>>63; bool sgnb=b.hi>>63; sub128_o(*(uint128_t*)&a, *(uint128_t*)&b, (uint128_t*)o); bool sgno = o->hi>>63; return (sgna!=sgnb && sgno != sgna); }
static inline bool mul128s_o(int128_t a, int128_t b, int128_t* o) { bool sgna = (a.hi >> 63); bool sgnb = (b.hi >> 63); if(sgna) a = neg128s(a); if(sgnb) b = neg128s(b); bool rv = mul128_o(*(uint128_t*)&a, *(uint128_t*)&b, (uint128_t*)o); if(sgna != sgnb) *o = neg128s(*o); return rv; }
static inline bool div128s_o(int128_t a, int128_t b, int128_t* q, int128_t* r) { bool sgna = (a.hi >> 63) != 0; bool sgnb = (b.hi >> 63) != 0; if(sgna) a = neg128s(a); if(sgnb) b = neg128s(b); bool rv = div128_o(*(uint128_t*)&a, *(uint128_t*)&b, (uint128_t*)q, (uint128_t*)r); if(sgna != sgnb && q) *q = neg128s(*q); if(sgna && r) *r = neg128s(*r); return rv; }
static inline int128_t add128s(int128_t a, int128_t b) { int128_t v; add128s_o(a, b, &v); return v; }
static inline int128_t sub128s(int128_t a, int128_t b) { int128_t v; sub128s_o(a, b, &v); return v; }
static inline int128_t mul128s(int128_t a, int128_t b) { int128_t v; mul128s_o(a, b, &v); return v; }
static inline int128_t div128s(int128_t a, int128_t b) { int128_t v; div128s_o(a, b, &v, NULL); return v; }
static inline int128_t mod128s(int128_t a, int128_t b) { int128_t v; div128s_o(a, b, NULL, &v); return v; }
static inline int128_t and128s(int128_t a, int128_t b) { int128_t v = { a.lo & b.lo, a.hi & b.hi }; return v; }
static inline int128_t or128s (int128_t a, int128_t b) { int128_t v = { a.lo | b.lo, a.hi | b.hi }; return v; }
static inline int128_t xor128s(int128_t a, int128_t b) { int128_t v = { a.lo ^ b.lo, a.hi ^ b.hi }; return v; }
static inline int128_t shl128s(int128_t a, uint32_t b) { int128_t v; if(b == 0) { return a; } else if(b < 64) { v.lo = a.lo << b; v.hi = (a.hi << b) | (a.lo >> (64 - b)); } else { v.hi = a.lo << (b - 64); v.lo = 0; } return v; }
static inline int128_t shr128s(int128_t a, uint32_t b) { int128_t v; if(b == 0) { return a; } else if(b < 64) { v.lo = (a.lo >> b)|(a.hi << (64 - b)); v.hi = (int64_t)a.hi >> b; } else { v.lo = (int64_t)a.hi >> (b - 64); v.hi = (int64_t)a.hi < 0 ? -1 : 0; } return v; }

static inline int slice_cmp(SLICE_PTR l, SLICE_PTR r) {
	int rv = memcmp(l.PTR, r.PTR, l.META < r.META ? l.META : r.META);
	if(rv != 0) return rv;
	if(l.META < r.META) return -1;
	if(l.META > r.META) return 1;
	return 0;
}
static inline SLICE_PTR make_sliceptr(void* ptr, size_t s) { SLICE_PTR rv = { ptr, s }; return rv; }
static inline TRAITOBJ_PTR make_traitobjptr(void* ptr, void* vt) { TRAITOBJ_PTR rv = { ptr, vt }; return rv; }

static inline size_t mrustc_max(size_t a, size_t b) { return a < b ? b : a; }
static inline void noop_drop(tUNIT *p) { }

static inline size_t mrustc_string_search_linear(SLICE_PTR val, size_t count, SLICE_PTR* options) {
	for(size_t i = 0; i < count; i ++) {
		int cmp = slice_cmp(val, options[i]);
		if(cmp < 0) break;
		if(cmp == 0) return i;
	}
	return SIZE_MAX;
}
static const uint8_t __mrustc_revmap[16] = { 0, 8, 4,12, 2,10, 6,14,  1, 9, 5,13, 3, 7,15};
static inline uint8_t __mrustc_bitrev8(uint8_t v) { if(v==0||v==0xFF) return v; return __mrustc_revmap[v>>4]|(__mrustc_revmap[v&15]<<4); }
static inline uint16_t __mrustc_bitrev16(uint16_t v) { if(v==0) return 0; return ((uint16_t)__mrustc_bitrev8(v>>8))|((uint16_t)__mrustc_bitrev8(v)<<8); }
static inline uint32_t __mrustc_bitrev32(uint32_t v) { if(v==0) return 0; return ((uint32_t)__mrustc_bitrev16(v>>16))|((uint32_t)__mrustc_bitrev16(v)<<16); }
static inline uint64_t __mrustc_bitrev64(uint64_t v) { if(v==0) return 0; return ((uint64_t)__mrustc_bitrev32(v>>32))|((uint64_t)__mrustc_bitrev32(v)<<32); }
static inline uint128_t __mrustc_bitrev128(uint128_t v) { uint128_t rv = { __mrustc_bitrev64(v.hi), __mrustc_bitrev64(v.lo) }; return rv; }
static inline uint8_t __mrustc_op_umax8(uint8_t a, uint8_t b) { return (a > b ? a : b); }
static inline uint8_t __mrustc_op_umin8(uint8_t a, uint8_t b) { return (a < b ? a : b); }
static inline uint8_t __mrustc_op_imax8(uint8_t a, uint8_t b) { return ((int8_t)a > (int8_t)b ? a : b); }
static inline uint8_t __mrustc_op_imin8(uint8_t a, uint8_t b) { return ((int8_t)a < (int8_t)b ? a : b); }
static inline uint8_t __mrustc_op_and_not8(uint8_t a, uint8_t b) { return ~(a & b); }
static inline uint16_t __mrustc_op_umax16(uint16_t a, uint16_t b) { return (a > b ? a : b); }
static inline uint16_t __mrustc_op_umin16(uint16_t a, uint16_t b) { return (a < b ? a : b); }
static inline uint16_t __mrustc_op_imax16(uint16_t a, uint16_t b) { return ((int16_t)a > (int16_t)b ? a : b); }
static inline uint16_t __mrustc_op_imin16(uint16_t a, uint16_t b) { return ((int16_t)a < (int16_t)b ? a : b); }
static inline uint16_t __mrustc_op_and_not16(uint16_t a, uint16_t b) { return ~(a & b); }
static inline uint32_t __mrustc_op_umax32(uint32_t a, uint32_t b) { return (a > b ? a : b); }
static inline uint32_t __mrustc_op_umin32(uint32_t a, uint32_t b) { return (a < b ? a : b); }
static inline uint32_t __mrustc_op_imax32(uint32_t a, uint32_t b) { return ((int32_t)a > (int32_t)b ? a : b); }
static inline uint32_t __mrustc_op_imin32(uint32_t a, uint32_t b) { return ((int32_t)a < (int32_t)b ? a : b); }
static inline uint32_t __mrustc_op_and_not32(uint32_t a, uint32_t b) { return ~(a & b); }
static inline uint64_t __mrustc_op_umax64(uint64_t a, uint64_t b) { return (a > b ? a : b); }
static inline uint64_t __mrustc_op_umin64(uint64_t a, uint64_t b) { return (a < b ? a : b); }
static inline uint64_t __mrustc_op_imax64(uint64_t a, uint64_t b) { return ((int64_t)a > (int64_t)b ? a : b); }
static inline uint64_t __mrustc_op_imin64(uint64_t a, uint64_t b) { return ((int64_t)a < (int64_t)b ? a : b); }
static inline uint64_t __mrustc_op_and_not64(uint64_t a, uint64_t b) { return ~(a & b); }
struct s_ZRG2cG11unwind0_0_09libunwind17_Unwind_Exception0g;
struct e_ZRG2cG11unwind0_0_09libunwind15_Unwind_Context0g;
// enum ::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code
struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g {
	uint32_t TAG;
};
typedef char sizeof_assert_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g[ (sizeof(struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g) == 4) ? 1 : -1 ];
struct e_ZRG2cE9core0_0_03ffi6c_void0g;
typedef struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g  (*t_ZRTFe1C2PuG2cG11unwind0_0_09libunwind15_Unwind_Context0gPuG2cE9core0_0_03ffi6c_void0gG2c_A_B19_Unwind_Reason_Code0g )( struct e_ZRG2cG11unwind0_0_09libunwind15_Unwind_Context0g *, struct e_ZRG2cE9core0_0_03ffi6c_void0g * ); // extern "C" fn(*mut ::"unwind-0_0_0"::libunwind::_Unwind_Context/*E*/, *mut ::"core-0_0_0"::ffi::c_void/*E*/, ) -> ::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/
// enum ::"unwind-0_0_0"::libunwind::_Unwind_Action
struct e_ZRG2cG11unwind0_0_09libunwind14_Unwind_Action0g {
	uint32_t TAG;
};
typedef char sizeof_assert_ZRG2cG11unwind0_0_09libunwind14_Unwind_Action0g[ (sizeof(struct e_ZRG2cG11unwind0_0_09libunwind14_Unwind_Action0g) == 4) ? 1 : -1 ];
// struct ::"core-0_0_0"::result::Result#Ok<(),::"core-0_0_0"::fmt::Error/*S*/,>
struct s_ZRG2cE9core0_0_06resultG8ResultOk2gT0G2c_A3fmt5Error0g  {
	/*@0*/uint8_t _1; // u8
	/*@1*/// ZST; // ()
} __attribute__((__aligned__(1),)) ;
typedef char sizeof_assert_ZRG2cE9core0_0_06resultG8ResultOk2gT0G2c_A3fmt5Error0g[ (sizeof(struct s_ZRG2cE9core0_0_06resultG8ResultOk2gT0G2c_A3fmt5Error0g) == 1) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_06resultG8ResultOk2gT0G2c_A3fmt5Error0g[ (ALIGNOF(struct s_ZRG2cE9core0_0_06resultG8ResultOk2gT0G2c_A3fmt5Error0g) == 1) ? 1 : -1 ];
// struct ::"core-0_0_0"::fmt::Error
struct s_ZRG2cE9core0_0_03fmt5Error0g  {
	char _d;
} __attribute__((__aligned__(1),)) ;
typedef char alignof_assert_ZRG2cE9core0_0_03fmt5Error0g[ (ALIGNOF(struct s_ZRG2cE9core0_0_03fmt5Error0g) == 1) ? 1 : -1 ];
// struct ::"core-0_0_0"::result::Result#Err<(),::"core-0_0_0"::fmt::Error/*S*/,>
struct s_ZRG2cE9core0_0_06resultG9ResultErr2gT0G2c_A3fmt5Error0g  {
	/*@0*/uint8_t _1; // u8
	/*@1*/// ZST; // ::"core-0_0_0"::fmt::Error/*S*/
} __attribute__((__aligned__(1),)) ;
typedef char sizeof_assert_ZRG2cE9core0_0_06resultG9ResultErr2gT0G2c_A3fmt5Error0g[ (sizeof(struct s_ZRG2cE9core0_0_06resultG9ResultErr2gT0G2c_A3fmt5Error0g) == 1) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_06resultG9ResultErr2gT0G2c_A3fmt5Error0g[ (ALIGNOF(struct s_ZRG2cE9core0_0_06resultG9ResultErr2gT0G2c_A3fmt5Error0g) == 1) ? 1 : -1 ];
// enum ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>
struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g {
	union {
		struct s_ZRG2cE9core0_0_06resultG8ResultOk2gT0G2c_A3fmt5Error0g var_0;
		struct s_ZRG2cE9core0_0_06resultG9ResultErr2gT0G2c_A3fmt5Error0g var_1;
		uint8_t TAG;
	} DATA;
};
typedef char sizeof_assert_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g[ (sizeof(struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g) == 1) ? 1 : -1 ];
struct s_ZRG2cE9core0_0_03fmt9Formatter0g;
// enum ::"core-0_0_0"::fmt::rt::v1::Alignment
struct e_ZRG4cE9core0_0_03fmt2rt2v19Alignment0g {
	int8_t TAG;
};
typedef char sizeof_assert_ZRG4cE9core0_0_03fmt2rt2v19Alignment0g[ (sizeof(struct e_ZRG4cE9core0_0_03fmt2rt2v19Alignment0g) == 1) ? 1 : -1 ];
// struct ::"core-0_0_0"::option::Option#Some<usize,>
struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCu  {
	/*@0*/uint8_t _1; // u8
	/*@8*/uintptr_t _0; // usize
} ;
typedef char sizeof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gCu[ (sizeof(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCu) == 16) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gCu[ (ALIGNOF(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCu) == 8) ? 1 : -1 ];
// enum ::"core-0_0_0"::option::Option<usize,>
struct e_ZRG2cE9core0_0_06option6Option1gCu {
	union {
		// ZST: ()
		struct s_ZRG2cE9core0_0_06optionG10OptionSome1gCu var_1;
		uint8_t TAG;
	} DATA;
};
typedef char sizeof_assert_ZRG2cE9core0_0_06option6Option1gCu[ (sizeof(struct e_ZRG2cE9core0_0_06option6Option1gCu) == 16) ? 1 : -1 ];
// struct ::"core-0_0_0"::fmt::Formatter<'#omitted,>
struct s_ZRG2cE9core0_0_03fmt9Formatter0g  {
	/*@0*/struct e_ZRG4cE9core0_0_03fmt2rt2v19Alignment0g _2; // ::"core-0_0_0"::fmt::rt::v1::Alignment/*E*/
	/*@4*/uint32_t _0; // u32
	/*@8*/RUST_CHAR _1; // char
	/*@16*/struct e_ZRG2cE9core0_0_06option6Option1gCu _3; // ::"core-0_0_0"::option::Option<usize,>/*E*/
	/*@32*/struct e_ZRG2cE9core0_0_06option6Option1gCu _4; // ::"core-0_0_0"::option::Option<usize,>/*E*/
	/*@48*/TRAITOBJ_PTR _5; // &'#omitted mut dyn (::"core-0_0_0"::fmt::Write+'#omitted)
} ;
typedef char sizeof_assert_ZRG2cE9core0_0_03fmt9Formatter0g[ (sizeof(struct s_ZRG2cE9core0_0_03fmt9Formatter0g) == 64) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_03fmt9Formatter0g[ (ALIGNOF(struct s_ZRG2cE9core0_0_03fmt9Formatter0g) == 8) ? 1 : -1 ];
// PROTO extern "Rust" <::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/ as ::"core-0_0_0"::clone::Clone>::clone<'#omitted,>
struct e_ZRG2cG11unwind0_0_09libunwind14_Unwind_Action0g  ZRQG2cG11unwind0_0_09libunwind14_Unwind_Action0g2cE9core0_0_05clone5Clone0g_E0g(
		struct e_ZRG2cG11unwind0_0_09libunwind14_Unwind_Action0g *arg0 // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/
		) // -> ::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/
;
// PROTO extern "Rust" <::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/ as ::"core-0_0_0"::clone::Clone>::clone_from<'#omitted,'#omitted,>
static void  ZRQG2cG11unwind0_0_09libunwind14_Unwind_Action0g2cE9core0_0_05clone5Clone0g10clone_from0g(
		struct e_ZRG2cG11unwind0_0_09libunwind14_Unwind_Action0g *arg0, // &'#omitted mut ::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/
		struct e_ZRG2cG11unwind0_0_09libunwind14_Unwind_Action0g *arg1 // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/
		) // -> ()
;
// PROTO extern "Rust" <::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/,>>::eq<'#omitted,'#omitted,>
RUST_BOOL  ZRQG2cG11unwind0_0_09libunwind14_Unwind_Action0g2cE9core0_0_03cmp9PartialEq1gG2c_A_B_C0g2eq0g(
		struct e_ZRG2cG11unwind0_0_09libunwind14_Unwind_Action0g *arg0, // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/
		struct e_ZRG2cG11unwind0_0_09libunwind14_Unwind_Action0g *arg1 // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/
		) // -> bool
;
// PROTO extern "Rust" <::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/,>>::ne<'#omitted,'#omitted,>
static RUST_BOOL  ZRQG2cG11unwind0_0_09libunwind14_Unwind_Action0g2cE9core0_0_03cmp9PartialEq1gG2c_A_B_C0g2ne0g(
		struct e_ZRG2cG11unwind0_0_09libunwind14_Unwind_Action0g *arg0, // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/
		struct e_ZRG2cG11unwind0_0_09libunwind14_Unwind_Action0g *arg1 // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/
		) // -> bool
;
// PROTO extern "Rust" <::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/ as ::"core-0_0_0"::clone::Clone>::clone<'#omitted,>
struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g  ZRQG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g2cE9core0_0_05clone5Clone0g_E0g(
		struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g *arg0 // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/
		) // -> ::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/
;
// PROTO extern "Rust" <::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/ as ::"core-0_0_0"::clone::Clone>::clone_from<'#omitted,'#omitted,>
static void  ZRQG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g2cE9core0_0_05clone5Clone0g10clone_from0g(
		struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g *arg0, // &'#omitted mut ::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/
		struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g *arg1 // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/
		) // -> ()
;
// PROTO extern "Rust" <::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/,>>::eq<'#omitted,'#omitted,>
RUST_BOOL  ZRQG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g2cE9core0_0_03cmp9PartialEq1gG2c_A_B_C0g2eq0g(
		struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g *arg0, // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/
		struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g *arg1 // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/
		) // -> bool
;
// PROTO extern "Rust" <::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/,>>::ne<'#omitted,'#omitted,>
static RUST_BOOL  ZRQG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g2cE9core0_0_03cmp9PartialEq1gG2c_A_B_C0g2ne0g(
		struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g *arg0, // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/
		struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g *arg1 // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/
		) // -> bool
;
// PROTO extern "Rust" <::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/ as ::"core-0_0_0"::fmt::Debug>::fmt<'#omitted,'#omitted,>
struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g  ZRQG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g2cE9core0_0_03fmt5Debug0g_E0g(
		struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g *arg0, // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/
		struct s_ZRG2cE9core0_0_03fmt9Formatter0g *arg1 // &'#omitted mut ::"core-0_0_0"::fmt::Formatter<'#omitted,>/*S*/
		) // -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/
;
// EXTERN extern "C" ::"unwind-0_0_0"::libunwind::_Unwind_Backtrace
extern struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g  ZRG2cG11unwind0_0_09libunwind17_Unwind_Backtrace0g(
		t_ZRTFe1C2PuG2cG11unwind0_0_09libunwind15_Unwind_Context0gPuG2cE9core0_0_03ffi6c_void0gG2c_A_B19_Unwind_Reason_Code0g arg0, // extern "C" fn(*mut ::"unwind-0_0_0"::libunwind::_Unwind_Context/*E*/, *mut ::"core-0_0_0"::ffi::c_void/*E*/, ) -> ::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/
		struct e_ZRG2cE9core0_0_03ffi6c_void0g *arg1 // *mut ::"core-0_0_0"::ffi::c_void/*E*/
		) // -> ::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/
 asm("_Unwind_Backtrace");
// EXTERN extern "C" ::"unwind-0_0_0"::libunwind::_Unwind_DeleteException
extern void  ZRG2cG11unwind0_0_09libunwind23_Unwind_DeleteException0g(
		struct s_ZRG2cG11unwind0_0_09libunwind17_Unwind_Exception0g *arg0 // *mut ::"unwind-0_0_0"::libunwind::_Unwind_Exception/*S*/
		) // -> ()
 asm("_Unwind_DeleteException");
// EXTERN extern "C" ::"unwind-0_0_0"::libunwind::_Unwind_FindEnclosingFunction
extern struct e_ZRG2cE9core0_0_03ffi6c_void0g * ZRG2cG11unwind0_0_09libunwind29_Unwind_FindEnclosingFunction0g(
		struct e_ZRG2cE9core0_0_03ffi6c_void0g *arg0 // *mut ::"core-0_0_0"::ffi::c_void/*E*/
		) // -> *mut ::"core-0_0_0"::ffi::c_void/*E*/
 asm("_Unwind_FindEnclosingFunction");
// EXTERN extern "C" ::"unwind-0_0_0"::libunwind::_Unwind_GetDataRelBase
extern uintptr_t  ZRG2cG11unwind0_0_09libunwind22_Unwind_GetDataRelBase0g(
		struct e_ZRG2cG11unwind0_0_09libunwind15_Unwind_Context0g *arg0 // *mut ::"unwind-0_0_0"::libunwind::_Unwind_Context/*E*/
		) // -> usize
 asm("_Unwind_GetDataRelBase");
// EXTERN extern "C" ::"unwind-0_0_0"::libunwind::_Unwind_GetGR
extern uintptr_t  ZRG2cG11unwind0_0_09libunwind13_Unwind_GetGR0g(
		struct e_ZRG2cG11unwind0_0_09libunwind15_Unwind_Context0g *arg0, // *mut ::"unwind-0_0_0"::libunwind::_Unwind_Context/*E*/
		int32_t arg1 // i32
		) // -> usize
 asm("_Unwind_GetGR");
// EXTERN extern "C" ::"unwind-0_0_0"::libunwind::_Unwind_GetIP
extern uintptr_t  ZRG2cG11unwind0_0_09libunwind13_Unwind_GetIP0g(
		struct e_ZRG2cG11unwind0_0_09libunwind15_Unwind_Context0g *arg0 // *mut ::"unwind-0_0_0"::libunwind::_Unwind_Context/*E*/
		) // -> usize
 asm("_Unwind_GetIP");
// EXTERN extern "C" ::"unwind-0_0_0"::libunwind::_Unwind_GetIPInfo
extern uintptr_t  ZRG2cG11unwind0_0_09libunwind17_Unwind_GetIPInfo0g(
		struct e_ZRG2cG11unwind0_0_09libunwind15_Unwind_Context0g *arg0, // *mut ::"unwind-0_0_0"::libunwind::_Unwind_Context/*E*/
		int32_t *arg1 // *mut i32
		) // -> usize
 asm("_Unwind_GetIPInfo");
// EXTERN extern "C" ::"unwind-0_0_0"::libunwind::_Unwind_GetLanguageSpecificData
extern struct e_ZRG2cE9core0_0_03ffi6c_void0g * ZRG2cG11unwind0_0_09libunwind31_Unwind_GetLanguageSpecificData0g(
		struct e_ZRG2cG11unwind0_0_09libunwind15_Unwind_Context0g *arg0 // *mut ::"unwind-0_0_0"::libunwind::_Unwind_Context/*E*/
		) // -> *mut ::"core-0_0_0"::ffi::c_void/*E*/
 asm("_Unwind_GetLanguageSpecificData");
// EXTERN extern "C" ::"unwind-0_0_0"::libunwind::_Unwind_GetRegionStart
extern uintptr_t  ZRG2cG11unwind0_0_09libunwind22_Unwind_GetRegionStart0g(
		struct e_ZRG2cG11unwind0_0_09libunwind15_Unwind_Context0g *arg0 // *mut ::"unwind-0_0_0"::libunwind::_Unwind_Context/*E*/
		) // -> usize
 asm("_Unwind_GetRegionStart");
// EXTERN extern "C" ::"unwind-0_0_0"::libunwind::_Unwind_GetTextRelBase
extern uintptr_t  ZRG2cG11unwind0_0_09libunwind22_Unwind_GetTextRelBase0g(
		struct e_ZRG2cG11unwind0_0_09libunwind15_Unwind_Context0g *arg0 // *mut ::"unwind-0_0_0"::libunwind::_Unwind_Context/*E*/
		) // -> usize
 asm("_Unwind_GetTextRelBase");
// EXTERN extern "C" ::"unwind-0_0_0"::libunwind::_Unwind_RaiseException
// - Magic compiler impl
static struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g  ZRG2cG11unwind0_0_09libunwind22_Unwind_RaiseException0g(
		struct s_ZRG2cG11unwind0_0_09libunwind17_Unwind_Exception0g *arg0 // *mut ::"unwind-0_0_0"::libunwind::_Unwind_Exception/*S*/
		) // -> ::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/
 {
	if( !mrustc_panic_target ) abort();
	mrustc_panic_value = arg0;
	longjmp(*mrustc_panic_target, 1);
}
// EXTERN extern "C" ::"unwind-0_0_0"::libunwind::_Unwind_Resume
extern tBANG  ZRG2cG11unwind0_0_09libunwind14_Unwind_Resume0g(
		struct s_ZRG2cG11unwind0_0_09libunwind17_Unwind_Exception0g *arg0 // *mut ::"unwind-0_0_0"::libunwind::_Unwind_Exception/*S*/
		) // -> !
 asm("_Unwind_Resume");
// EXTERN extern "C" ::"unwind-0_0_0"::libunwind::_Unwind_SetGR
extern void  ZRG2cG11unwind0_0_09libunwind13_Unwind_SetGR0g(
		struct e_ZRG2cG11unwind0_0_09libunwind15_Unwind_Context0g *arg0, // *mut ::"unwind-0_0_0"::libunwind::_Unwind_Context/*E*/
		int32_t arg1, // i32
		uintptr_t arg2 // usize
		) // -> ()
 asm("_Unwind_SetGR");
// EXTERN extern "C" ::"unwind-0_0_0"::libunwind::_Unwind_SetIP
extern void  ZRG2cG11unwind0_0_09libunwind13_Unwind_SetIP0g(
		struct e_ZRG2cG11unwind0_0_09libunwind15_Unwind_Context0g *arg0, // *mut ::"unwind-0_0_0"::libunwind::_Unwind_Context/*E*/
		uintptr_t arg1 // usize
		) // -> ()
 asm("_Unwind_SetIP");
// EXTERN extern "Rust" <::"core-0_0_0"::fmt::Formatter<'static,>/*S*/ /*- <'#omitted,>*/>::write_str<'#omitted,'static,>
extern struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g  ZRIG2cE9core0_0_03fmt9Formatter0g9write_str0g(
		struct s_ZRG2cE9core0_0_03fmt9Formatter0g *arg0, // &'#omitted mut ::"core-0_0_0"::fmt::Formatter<'#omitted,>/*S*/
		SLICE_PTR arg1 // &'static str
		) // -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/
;
// <::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/ as ::"core-0_0_0"::clone::Clone>::clone<'#omitted,>
struct e_ZRG2cG11unwind0_0_09libunwind14_Unwind_Action0g  ZRQG2cG11unwind0_0_09libunwind14_Unwind_Action0g2cE9core0_0_05clone5Clone0g_E0g(
		struct e_ZRG2cG11unwind0_0_09libunwind14_Unwind_Action0g *arg0 // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/
		) // -> ::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/

{
	struct e_ZRG2cG11unwind0_0_09libunwind14_Unwind_Action0g rv;
	switch((*arg0).TAG) {
	case 1: goto bb1;break;
	case 2: goto bb2;break;
	case 4: goto bb3;break;
	case 8: goto bb4;break;
	case 16: goto bb5;break;
	default: abort();
	}
	// ^ Switch( a0* : 0 => bb1, 1 => bb2, 2 => bb3, 3 => bb4, 4 => bb5, )
bb1:
	rv.TAG = 1;	// retval = Variant(::"unwind-0_0_0"::libunwind::_Unwind_Action #0, {})
	return rv;
	// ^ Return
bb2:
	rv.TAG = 2;	// retval = Variant(::"unwind-0_0_0"::libunwind::_Unwind_Action #1, {})
	return rv;
	// ^ Return
bb3:
	rv.TAG = 4;	// retval = Variant(::"unwind-0_0_0"::libunwind::_Unwind_Action #2, {})
	return rv;
	// ^ Return
bb4:
	rv.TAG = 8;	// retval = Variant(::"unwind-0_0_0"::libunwind::_Unwind_Action #3, {})
	return rv;
	// ^ Return
bb5:
	rv.TAG = 16;	// retval = Variant(::"unwind-0_0_0"::libunwind::_Unwind_Action #4, {})
	return rv;
	// ^ Return
}
// <::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/ as ::"core-0_0_0"::clone::Clone>::clone_from<'#omitted,'#omitted,>
static void  ZRQG2cG11unwind0_0_09libunwind14_Unwind_Action0g2cE9core0_0_05clone5Clone0g10clone_from0g(
		struct e_ZRG2cG11unwind0_0_09libunwind14_Unwind_Action0g *arg0, // &'#omitted mut ::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/
		struct e_ZRG2cG11unwind0_0_09libunwind14_Unwind_Action0g *arg1 // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/
		) // -> ()

{
	tUNIT rv;
	(*arg0) = ZRQG2cG11unwind0_0_09libunwind14_Unwind_Action0g2cE9core0_0_05clone5Clone0g_E0g( arg1 );
	// ^ Call( a0* = <::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/ as ::"core-0_0_0"::clone::Clone>::clone<'#omitted,>( a1, ), bb1, bb2)
	/* ZST assign */
	// ^ drop(a0)
	return ;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/,>>::eq<'#omitted,'#omitted,>
RUST_BOOL  ZRQG2cG11unwind0_0_09libunwind14_Unwind_Action0g2cE9core0_0_03cmp9PartialEq1gG2c_A_B_C0g2eq0g(
		struct e_ZRG2cG11unwind0_0_09libunwind14_Unwind_Action0g *arg0, // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/
		struct e_ZRG2cG11unwind0_0_09libunwind14_Unwind_Action0g *arg1 // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/
		) // -> bool

{
	RUST_BOOL rv;
	struct e_ZRG2cG11unwind0_0_09libunwind14_Unwind_Action0g *var0;	// &'M0 ::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/
	struct e_ZRG2cG11unwind0_0_09libunwind14_Unwind_Action0g *var1;	// &'M0 ::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/
	var0 = arg0;	// _0 = Use(a0)
	var1 = arg1;	// _1 = Use(a1)
	switch((*var0).TAG) {
	case 1: goto bb1;break;
	case 2: goto bb2;break;
	case 4: goto bb3;break;
	case 8: goto bb4;break;
	case 16: goto bb5;break;
	default: abort();
	}
	// ^ Switch( _0* : 0 => bb1, 1 => bb2, 2 => bb3, 3 => bb4, 4 => bb5, )
bb1:
	if((*var1).TAG == 1) {goto bb7;} else {goto bb6;}
	// ^ Switch( _1* : 0 => bb7, 1 => bb6, 2 => bb6, 3 => bb6, 4 => bb6, )
bb2:
	if((*var1).TAG == 2) {goto bb7;} else {goto bb6;}
	// ^ Switch( _1* : 0 => bb6, 1 => bb7, 2 => bb6, 3 => bb6, 4 => bb6, )
bb3:
	if((*var1).TAG == 4) {goto bb7;} else {goto bb6;}
	// ^ Switch( _1* : 0 => bb6, 1 => bb6, 2 => bb7, 3 => bb6, 4 => bb6, )
bb4:
	if((*var1).TAG == 8) {goto bb7;} else {goto bb6;}
	// ^ Switch( _1* : 0 => bb6, 1 => bb6, 2 => bb6, 3 => bb7, 4 => bb6, )
bb5:
	if((*var1).TAG == 16) {goto bb7;} else {goto bb6;}
	// ^ Switch( _1* : 0 => bb6, 1 => bb6, 2 => bb6, 3 => bb6, 4 => bb7, )
bb6:
	rv = false;	// retval = Constant(false)
	return rv;
	// ^ Return
bb7:
	rv = true;	// retval = Constant(true)
	return rv;
	// ^ Return
}
// <::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/,>>::ne<'#omitted,'#omitted,>
static RUST_BOOL  ZRQG2cG11unwind0_0_09libunwind14_Unwind_Action0g2cE9core0_0_03cmp9PartialEq1gG2c_A_B_C0g2ne0g(
		struct e_ZRG2cG11unwind0_0_09libunwind14_Unwind_Action0g *arg0, // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/
		struct e_ZRG2cG11unwind0_0_09libunwind14_Unwind_Action0g *arg1 // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/
		) // -> bool

{
	RUST_BOOL rv;
	RUST_BOOL var0;	// bool
	var0 = ZRQG2cG11unwind0_0_09libunwind14_Unwind_Action0g2cE9core0_0_03cmp9PartialEq1gG2c_A_B_C0g2eq0g( arg0, arg1 );
	// ^ Call( _0 = <::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"unwind-0_0_0"::libunwind::_Unwind_Action/*E*/,>>::eq<'#omitted,'#omitted,>( a0, a1, ), bb1, bb2)
	rv = !var0;	// retval = UniOp(_0 INV)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/ as ::"core-0_0_0"::clone::Clone>::clone<'#omitted,>
struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g  ZRQG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g2cE9core0_0_05clone5Clone0g_E0g(
		struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g *arg0 // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/
		) // -> ::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/

{
	struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g rv;
	switch((*arg0).TAG) {
	case 0: goto bb1;break;
	case 1: goto bb2;break;
	case 2: goto bb3;break;
	case 3: goto bb4;break;
	case 4: goto bb5;break;
	case 5: goto bb6;break;
	case 6: goto bb7;break;
	case 7: goto bb8;break;
	case 8: goto bb9;break;
	case 9: goto bb10;break;
	default: abort();
	}
	// ^ Switch( a0* : 0 => bb1, 1 => bb2, 2 => bb3, 3 => bb4, 4 => bb5, 5 => bb6, 6 => bb7, 7 => bb8, 8 => bb9, 9 => bb10, )
bb1:
	rv.TAG = 0;	// retval = Variant(::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code #0, {})
	return rv;
	// ^ Return
bb2:
	rv.TAG = 1;	// retval = Variant(::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code #1, {})
	return rv;
	// ^ Return
bb3:
	rv.TAG = 2;	// retval = Variant(::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code #2, {})
	return rv;
	// ^ Return
bb4:
	rv.TAG = 3;	// retval = Variant(::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code #3, {})
	return rv;
	// ^ Return
bb5:
	rv.TAG = 4;	// retval = Variant(::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code #4, {})
	return rv;
	// ^ Return
bb6:
	rv.TAG = 5;	// retval = Variant(::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code #5, {})
	return rv;
	// ^ Return
bb7:
	rv.TAG = 6;	// retval = Variant(::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code #6, {})
	return rv;
	// ^ Return
bb8:
	rv.TAG = 7;	// retval = Variant(::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code #7, {})
	return rv;
	// ^ Return
bb9:
	rv.TAG = 8;	// retval = Variant(::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code #8, {})
	return rv;
	// ^ Return
bb10:
	rv.TAG = 9;	// retval = Variant(::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code #9, {})
	return rv;
	// ^ Return
}
// <::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/ as ::"core-0_0_0"::clone::Clone>::clone_from<'#omitted,'#omitted,>
static void  ZRQG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g2cE9core0_0_05clone5Clone0g10clone_from0g(
		struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g *arg0, // &'#omitted mut ::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/
		struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g *arg1 // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/
		) // -> ()

{
	tUNIT rv;
	(*arg0) = ZRQG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g2cE9core0_0_05clone5Clone0g_E0g( arg1 );
	// ^ Call( a0* = <::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/ as ::"core-0_0_0"::clone::Clone>::clone<'#omitted,>( a1, ), bb1, bb2)
	/* ZST assign */
	// ^ drop(a0)
	return ;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/,>>::eq<'#omitted,'#omitted,>
RUST_BOOL  ZRQG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g2cE9core0_0_03cmp9PartialEq1gG2c_A_B_C0g2eq0g(
		struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g *arg0, // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/
		struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g *arg1 // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/
		) // -> bool

{
	RUST_BOOL rv;
	struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g *var0;	// &'M0 ::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/
	struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g *var1;	// &'M0 ::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/
	var0 = arg0;	// _0 = Use(a0)
	var1 = arg1;	// _1 = Use(a1)
	switch((*var0).TAG) {
	case 0: goto bb1;break;
	case 1: goto bb2;break;
	case 2: goto bb3;break;
	case 3: goto bb4;break;
	case 4: goto bb5;break;
	case 5: goto bb6;break;
	case 6: goto bb7;break;
	case 7: goto bb8;break;
	case 8: goto bb9;break;
	case 9: goto bb10;break;
	default: abort();
	}
	// ^ Switch( _0* : 0 => bb1, 1 => bb2, 2 => bb3, 3 => bb4, 4 => bb5, 5 => bb6, 6 => bb7, 7 => bb8, 8 => bb9, 9 => bb10, )
bb1:
	if((*var1).TAG == 0) {goto bb12;} else {goto bb11;}
	// ^ Switch( _1* : 0 => bb12, 1 => bb11, 2 => bb11, 3 => bb11, 4 => bb11, 5 => bb11, 6 => bb11, 7 => bb11, 8 => bb11, 9 => bb11, )
bb2:
	if((*var1).TAG == 1) {goto bb12;} else {goto bb11;}
	// ^ Switch( _1* : 0 => bb11, 1 => bb12, 2 => bb11, 3 => bb11, 4 => bb11, 5 => bb11, 6 => bb11, 7 => bb11, 8 => bb11, 9 => bb11, )
bb3:
	if((*var1).TAG == 2) {goto bb12;} else {goto bb11;}
	// ^ Switch( _1* : 0 => bb11, 1 => bb11, 2 => bb12, 3 => bb11, 4 => bb11, 5 => bb11, 6 => bb11, 7 => bb11, 8 => bb11, 9 => bb11, )
bb4:
	if((*var1).TAG == 3) {goto bb12;} else {goto bb11;}
	// ^ Switch( _1* : 0 => bb11, 1 => bb11, 2 => bb11, 3 => bb12, 4 => bb11, 5 => bb11, 6 => bb11, 7 => bb11, 8 => bb11, 9 => bb11, )
bb5:
	if((*var1).TAG == 4) {goto bb12;} else {goto bb11;}
	// ^ Switch( _1* : 0 => bb11, 1 => bb11, 2 => bb11, 3 => bb11, 4 => bb12, 5 => bb11, 6 => bb11, 7 => bb11, 8 => bb11, 9 => bb11, )
bb6:
	if((*var1).TAG == 5) {goto bb12;} else {goto bb11;}
	// ^ Switch( _1* : 0 => bb11, 1 => bb11, 2 => bb11, 3 => bb11, 4 => bb11, 5 => bb12, 6 => bb11, 7 => bb11, 8 => bb11, 9 => bb11, )
bb7:
	if((*var1).TAG == 6) {goto bb12;} else {goto bb11;}
	// ^ Switch( _1* : 0 => bb11, 1 => bb11, 2 => bb11, 3 => bb11, 4 => bb11, 5 => bb11, 6 => bb12, 7 => bb11, 8 => bb11, 9 => bb11, )
bb8:
	if((*var1).TAG == 7) {goto bb12;} else {goto bb11;}
	// ^ Switch( _1* : 0 => bb11, 1 => bb11, 2 => bb11, 3 => bb11, 4 => bb11, 5 => bb11, 6 => bb11, 7 => bb12, 8 => bb11, 9 => bb11, )
bb9:
	if((*var1).TAG == 8) {goto bb12;} else {goto bb11;}
	// ^ Switch( _1* : 0 => bb11, 1 => bb11, 2 => bb11, 3 => bb11, 4 => bb11, 5 => bb11, 6 => bb11, 7 => bb11, 8 => bb12, 9 => bb11, )
bb10:
	if((*var1).TAG == 9) {goto bb12;} else {goto bb11;}
	// ^ Switch( _1* : 0 => bb11, 1 => bb11, 2 => bb11, 3 => bb11, 4 => bb11, 5 => bb11, 6 => bb11, 7 => bb11, 8 => bb11, 9 => bb12, )
bb11:
	rv = false;	// retval = Constant(false)
	return rv;
	// ^ Return
bb12:
	rv = true;	// retval = Constant(true)
	return rv;
	// ^ Return
}
// <::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/,>>::ne<'#omitted,'#omitted,>
static RUST_BOOL  ZRQG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g2cE9core0_0_03cmp9PartialEq1gG2c_A_B_C0g2ne0g(
		struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g *arg0, // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/
		struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g *arg1 // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/
		) // -> bool

{
	RUST_BOOL rv;
	RUST_BOOL var0;	// bool
	var0 = ZRQG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g2cE9core0_0_03cmp9PartialEq1gG2c_A_B_C0g2eq0g( arg0, arg1 );
	// ^ Call( _0 = <::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/ as ::"core-0_0_0"::cmp::PartialEq<::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/,>>::eq<'#omitted,'#omitted,>( a0, a1, ), bb1, bb2)
	rv = !var0;	// retval = UniOp(_0 INV)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/ as ::"core-0_0_0"::fmt::Debug>::fmt<'#omitted,'#omitted,>
struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g  ZRQG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g2cE9core0_0_03fmt5Debug0g_E0g(
		struct e_ZRG2cG11unwind0_0_09libunwind19_Unwind_Reason_Code0g *arg0, // &'#omitted ::"unwind-0_0_0"::libunwind::_Unwind_Reason_Code/*E*/
		struct s_ZRG2cE9core0_0_03fmt9Formatter0g *arg1 // &'#omitted mut ::"core-0_0_0"::fmt::Formatter<'#omitted,>/*S*/
		) // -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/

{
	struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g rv;
	struct s_ZRG2cE9core0_0_03fmt9Formatter0g *var0;	// &'M1 mut ::"core-0_0_0"::fmt::Formatter<'M1,>/*S*/
	struct s_ZRG2cE9core0_0_03fmt9Formatter0g *var1;	// &'M1 mut ::"core-0_0_0"::fmt::Formatter<'M1,>/*S*/
	struct s_ZRG2cE9core0_0_03fmt9Formatter0g *var2;	// &'M1 mut ::"core-0_0_0"::fmt::Formatter<'M1,>/*S*/
	struct s_ZRG2cE9core0_0_03fmt9Formatter0g *var3;	// &'M1 mut ::"core-0_0_0"::fmt::Formatter<'M1,>/*S*/
	struct s_ZRG2cE9core0_0_03fmt9Formatter0g *var4;	// &'M1 mut ::"core-0_0_0"::fmt::Formatter<'M1,>/*S*/
	struct s_ZRG2cE9core0_0_03fmt9Formatter0g *var5;	// &'M1 mut ::"core-0_0_0"::fmt::Formatter<'M1,>/*S*/
	struct s_ZRG2cE9core0_0_03fmt9Formatter0g *var6;	// &'M1 mut ::"core-0_0_0"::fmt::Formatter<'M1,>/*S*/
	struct s_ZRG2cE9core0_0_03fmt9Formatter0g *var7;	// &'M1 mut ::"core-0_0_0"::fmt::Formatter<'M1,>/*S*/
	struct s_ZRG2cE9core0_0_03fmt9Formatter0g *var8;	// &'M1 mut ::"core-0_0_0"::fmt::Formatter<'M1,>/*S*/
	struct s_ZRG2cE9core0_0_03fmt9Formatter0g *var9;	// &'M1 mut ::"core-0_0_0"::fmt::Formatter<'M1,>/*S*/
	switch((*arg0).TAG) {
	case 0: goto bb1;break;
	case 1: goto bb2;break;
	case 2: goto bb3;break;
	case 3: goto bb4;break;
	case 4: goto bb5;break;
	case 5: goto bb6;break;
	case 6: goto bb7;break;
	case 7: goto bb8;break;
	case 8: goto bb9;break;
	case 9: goto bb10;break;
	default: abort();
	}
	// ^ Switch( a0* : 0 => bb1, 1 => bb2, 2 => bb3, 3 => bb4, 4 => bb5, 5 => bb6, 6 => bb7, 7 => bb8, 8 => bb9, 9 => bb10, )
bb1:
	var0 = arg1;	// _0 = Borrow(Unique, a1*)
	rv = ZRIG2cE9core0_0_03fmt9Formatter0g9write_str0g( var0, make_sliceptr("_URC_NO_REASON", 14) );
	goto bb11;
	// ^ Call( retval = <::"core-0_0_0"::fmt::Formatter<'static,>/*S*/ /*- <'M1,>*/>::write_str<'M1,'static,>( _0, "_URC_NO_REASON", ), bb11, bb12)
bb2:
	var1 = arg1;	// _1 = Borrow(Unique, a1*)
	rv = ZRIG2cE9core0_0_03fmt9Formatter0g9write_str0g( var1, make_sliceptr("_URC_FOREIGN_EXCEPTION_CAUGHT", 29) );
	goto bb11;
	// ^ Call( retval = <::"core-0_0_0"::fmt::Formatter<'static,>/*S*/ /*- <'M1,>*/>::write_str<'M1,'static,>( _1, "_URC_FOREIGN_EXCEPTION_CAUGHT", ), bb11, bb12)
bb3:
	var2 = arg1;	// _2 = Borrow(Unique, a1*)
	rv = ZRIG2cE9core0_0_03fmt9Formatter0g9write_str0g( var2, make_sliceptr("_URC_FATAL_PHASE2_ERROR", 23) );
	goto bb11;
	// ^ Call( retval = <::"core-0_0_0"::fmt::Formatter<'static,>/*S*/ /*- <'M1,>*/>::write_str<'M1,'static,>( _2, "_URC_FATAL_PHASE2_ERROR", ), bb11, bb12)
bb4:
	var3 = arg1;	// _3 = Borrow(Unique, a1*)
	rv = ZRIG2cE9core0_0_03fmt9Formatter0g9write_str0g( var3, make_sliceptr("_URC_FATAL_PHASE1_ERROR", 23) );
	goto bb11;
	// ^ Call( retval = <::"core-0_0_0"::fmt::Formatter<'static,>/*S*/ /*- <'M1,>*/>::write_str<'M1,'static,>( _3, "_URC_FATAL_PHASE1_ERROR", ), bb11, bb12)
bb5:
	var4 = arg1;	// _4 = Borrow(Unique, a1*)
	rv = ZRIG2cE9core0_0_03fmt9Formatter0g9write_str0g( var4, make_sliceptr("_URC_NORMAL_STOP", 16) );
	goto bb11;
	// ^ Call( retval = <::"core-0_0_0"::fmt::Formatter<'static,>/*S*/ /*- <'M1,>*/>::write_str<'M1,'static,>( _4, "_URC_NORMAL_STOP", ), bb11, bb12)
bb6:
	var5 = arg1;	// _5 = Borrow(Unique, a1*)
	rv = ZRIG2cE9core0_0_03fmt9Formatter0g9write_str0g( var5, make_sliceptr("_URC_END_OF_STACK", 17) );
	goto bb11;
	// ^ Call( retval = <::"core-0_0_0"::fmt::Formatter<'static,>/*S*/ /*- <'M1,>*/>::write_str<'M1,'static,>( _5, "_URC_END_OF_STACK", ), bb11, bb12)
bb7:
	var6 = arg1;	// _6 = Borrow(Unique, a1*)
	rv = ZRIG2cE9core0_0_03fmt9Formatter0g9write_str0g( var6, make_sliceptr("_URC_HANDLER_FOUND", 18) );
	goto bb11;
	// ^ Call( retval = <::"core-0_0_0"::fmt::Formatter<'static,>/*S*/ /*- <'M1,>*/>::write_str<'M1,'static,>( _6, "_URC_HANDLER_FOUND", ), bb11, bb12)
bb8:
	var7 = arg1;	// _7 = Borrow(Unique, a1*)
	rv = ZRIG2cE9core0_0_03fmt9Formatter0g9write_str0g( var7, make_sliceptr("_URC_INSTALL_CONTEXT", 20) );
	goto bb11;
	// ^ Call( retval = <::"core-0_0_0"::fmt::Formatter<'static,>/*S*/ /*- <'M1,>*/>::write_str<'M1,'static,>( _7, "_URC_INSTALL_CONTEXT", ), bb11, bb12)
bb9:
	var8 = arg1;	// _8 = Borrow(Unique, a1*)
	rv = ZRIG2cE9core0_0_03fmt9Formatter0g9write_str0g( var8, make_sliceptr("_URC_CONTINUE_UNWIND", 20) );
	goto bb11;
	// ^ Call( retval = <::"core-0_0_0"::fmt::Formatter<'static,>/*S*/ /*- <'M1,>*/>::write_str<'M1,'static,>( _8, "_URC_CONTINUE_UNWIND", ), bb11, bb12)
bb10:
	var9 = arg1;	// _9 = Borrow(Unique, a1*)
	rv = ZRIG2cE9core0_0_03fmt9Formatter0g9write_str0g( var9, make_sliceptr("_URC_FAILURE", 12) );
	// ^ Call( retval = <::"core-0_0_0"::fmt::Formatter<'static,>/*S*/ /*- <'M1,>*/>::write_str<'M1,'static,>( _9, "_URC_FAILURE", ), bb11, bb12)
bb11:
	// ^ drop(a1)
	return rv;
	// ^ Return
bb12: _Unwind_Resume(); // Diverge
}
